use main2::main;
use pollster::block_on;
use wgpu::{Device, Queue, Surface, SwapChainDescriptor, TextureFormat};
use winit::{
    application::ApplicationHandler,
    dpi::LogicalSize,
    event::{DeviceEvent, ElementState, WindowEvent},
    event_loop::{ActiveEventLoop, ControlFlow, EventLoop},
    window::{Window, WindowId},
};

struct App {
    window: Option<Window>,
    surface: Option<Surface>,
    device: Option<Device>,
    queue: Option<Queue>,
    cursor_x: f32,
    cursor_y: f32,
    width: u32,
    height: u32,
}

impl Default for App {
    fn default() -> Self {
        Self {
            window: None,
            surface: None,
            device: None,
            queue: None,
            cursor_x: 400.0,
            cursor_y: 300.0,
            width: 800,
            height: 600,
        }
    }
}

impl ApplicationHandler for App {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        let window = event_loop
            .create_window(
                Window::default_attributes()
                    .with_inner_size(LogicalSize::new(800, 600))
                    .with_title("wgpu Cursor Example")
                    .with_transparent(true)
                    .with_decorations(false),
            )
            .unwrap();

        let instance = wgpu::Instance::default();
        let surface = unsafe { instance.create_surface(&window) }.unwrap();

        let adapter = block_on(instance.request_adapter(&wgpu::RequestAdapterOptions::default()))
            .expect("Failed to find a GPU adapter");

        let (device, queue) =
            block_on(adapter.request_device(&wgpu::DeviceDescriptor::default(), None))
                .expect("Failed to create device");

        self.window = Some(window);
        self.surface = Some(surface);
        self.device = Some(device);
        self.queue = Some(queue);
    }

    fn window_event(&mut self, event_loop: &ActiveEventLoop, id: WindowId, event: WindowEvent) {
        match event {
            WindowEvent::CloseRequested => {
                println!("Close button pressed. Exiting...");
                event_loop.exit();
            }
            WindowEvent::CursorMoved { position, .. } => {
                self.cursor_x = position.x as f32;
                self.cursor_y = position.y as f32;
                println!("Cursor moved to: ({}, {})", self.cursor_x, self.cursor_y);
                if let Some(window) = &self.window {
                    window.request_redraw();
                }
            }
            WindowEvent::CursorLeft { .. } => {
                println!("Cursor left the window. Resetting position.");
                self.cursor_x = self.width as f32 / 2.0;
                self.cursor_y = self.height as f32 / 2.0;
                if let Some(window) = &self.window {
                    window.request_redraw();
                }
            }
            WindowEvent::RedrawRequested => {
                self.draw_cursor();
            }
            _ => (),
        }
    }

    fn device_event(&mut self, _: &ActiveEventLoop, event: DeviceEvent) {
        if let DeviceEvent::Button { button, state } = event {
            if button == 1 && state == ElementState::Pressed {
                println!("Left mouse button clicked!");
            }
        }
    }
}

impl App {
    fn draw_cursor(&mut self) {
        if let (Some(device), Some(queue), Some(surface)) =
            (&self.device, &self.queue, &self.surface)
        {
            let size = wgpu::Extent3d {
                width: self.width,
                height: self.height,
                depth_or_array_layers: 1,
            };

            let texture_descriptor = wgpu::TextureDescriptor {
                label: Some("Cursor Texture"),
                size,
                mip_level_count: 1,
                sample_count: 1,
                dimension: wgpu::TextureDimension::D2,
                format: TextureFormat::Rgba8UnormSrgb,
                usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
                view_formats: &[],
            };

            let texture = device.create_texture(&texture_descriptor);
            let view = texture.create_view(&wgpu::TextureViewDescriptor::default());

            let encoder_descriptor = wgpu::CommandEncoderDescriptor {
                label: Some("Render Encoder"),
            };

            let mut encoder = device.create_command_encoder(&encoder_descriptor);

            // Clear screen
            let color = wgpu::Color {
                r: 0.0,
                g: 0.0,
                b: 0.0,
                a: 0.0, // Transparent background
            };

            // Draw a red dot at cursor position
            let cursor_color = wgpu::Color {
                r: 1.0,
                g: 0.0,
                b: 0.0,
                a: 1.0, // Opaque red
            };

            let render_pass_descriptor = wgpu::RenderPassDescriptor {
                label: Some("Cursor Render Pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view: &view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(color), // Clear background
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: None,
                timestamp_writes: None,
                occlusion_query_set: None,
            };

            let mut render_pass = encoder.begin_render_pass(&render_pass_descriptor);

            // Here you would add code to render a circle (red dot) at (cursor_x, cursor_y)

            drop(render_pass);
            queue.submit(Some(encoder.finish()));
        }
    }
}

fn main() {
    env_logger::init();
    let event_loop = EventLoop::new().unwrap();
    event_loop.set_control_flow(ControlFlow::Poll);

    let mut app = App::default();
    let _ = event_loop.run_app(&mut app).unwrap();
}
